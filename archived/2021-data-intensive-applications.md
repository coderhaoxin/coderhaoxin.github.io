---
title: (2021) 数据密集型应用系统设计
description: 江天一色无纤尘, 皎皎空中孤月轮. 江畔何人初见月? 江月何年初照人?
date: 2021-07-06
---

* [数据密集型应用系统设计](https://book.douban.com/subject/30329536/)
  - 原作名: Designing Data-Intensive Applications
  - 出版年: 2018-09-01

## 数据模型与查询语言

```
但是, 如果多对多的关系在数据中很常见呢?
关系模型能够处理简单的多对多关系,
但是随着数据之间的关联越来越复杂,
将数据建模转化为图模型会更加自然.

图由两种对象组成: 顶点 和 边 (也 称为关系)
```

> **关系**: 关联更多, 更深, 即: 更复杂

* Cypher (Neo4j)
* SPARQL
* Datalog (Prolog 子集)

## 数据存储与检索

* **Log**: 一个仅能追加的记录序列

```
日志结构的合并树
(Log-Structured Merge-Tree, 或 LSM-Tree),
它建立在更早期的日志结构文件系统之上.
因此基于合并和压缩排序文件的存储引擎通常都被称为 LSM 存储引擎.
```

```
当查找数据库中某个不存在的键时 LSM-Tree 算法可能很慢:
在确定键不存在之前, 必须先检查内存表,
然后将段一直回溯访问到最旧的段文件
(可能必须从磁盘多次读取).
为了优化这种访问, 存储引擎通常使用额外的布隆过滤器
(布隆过滤器是内存高效的数据结构, 用于近似计算集合的内容.
如果数据库中不存在某个键, 它能够很快告诉你结果,
从而节省了很多对于不存在的键的不必要的磁盘读取)
```

* LSM-tree

```
由于数据按排序存储, 因比可以有效地执行区间查询
(从最小值到最大值扫描所有的键),
并且由于磁盘是顺序写入的,
所以 LSM-tree 可以支持非常高的写入吞吐量.
```

* 对比 B-tree 和 LSM-tree

```
根据经验, LSM-tree 通常对于写人更快,
而 B-tree 被认为对于读取更快.
读取通常在 LSM-tree 上较慢,
因为它们必须在不同的压缩阶段检查多个不同的数据结构和 SSTable.
```

## 数据编码与演化

```
向后兼容:
  较新的代码 可以读取由 旧代码 编写的数据
向前兼容:
  较旧的代码 可以读取由 新代码 编写的数据
```

* OLAP 列式存储
  - 列压缩 位图编码

```
面向列的 存储压缩 和 排序 都非常有助于加速读取.
但是, 它们的缺点是让写人更加困难.
```

* Parquet

* **数据 比 代码 更长久!**
  - 哈哈!

## 数据复制

* 基于语句的复制
  - 如果遇到语句 `UPDATE ... WHERE ... NOW()`
  - 自增列, 触发器, 存储过程, UDF

* 基于预写日志 (WAL) 传输

* 基于行的逻辑日志复制
  - 变更数据捕获 (CDC)

### 复制滞后

## 数据分区

* 读自己的写
  - 用户 A 写入 `主`, 立即读 `从`
  - 写后读一致性/读写一致性

* 单调读

## 事务

## 分布式系统的挑战

## 一致性与共识

## 批处理系统

## 流处理系统

## 数据系统的未来

> 看看数年前的书预判未来的技术路线, 别有一番意境
