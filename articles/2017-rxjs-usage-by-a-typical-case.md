---
title: 从一个典型的场景看 rxjs 的应用
description: 记最近的一个案例
date: 2017-11-19
---

### 题记

最近正好在一个典型的业务场景中用到了 `rxjs` 解决一些数据管理的问题,
对相关的核心代码做了下总结梳理.
业务场景很常见, 基本做过 `admin` 类的前端开发的同学都很熟悉.
页面上方是 `条件筛选区`, 比如: `时间范围`, `数据类型` 等.
页面下方就是一张 `table` 展示查询结果.

是不是 90% 的 admin 页面都长得这式样 :) 但是, 也有一些特别的地方, 或者场景特殊限制.

### 需求一: 异步请求并发, 但响应结果保持时序

1. 由于后端数据量大, 查询逻辑非常复杂, 单次查询耗时 `500ms - 3000ms` 不等, 甚至更长
2. 使用者是运营人员, 操作会很频繁, 不接受每次变更查询条件后手动点击 `查询` 按钮触发查询, 即: 筛选条件变更, 自动查询

原本, 常见的场景中, 不会有用户操作是 `秒级` 的, 咱也不是秒杀下单.
同时, 大多的前后端业务交互的 http 请求也基本在数百毫秒.
但由于上述条件限制, 相关的技术需求就是:

前端会发送 n 次 http request, 但 response 的时序很大概率是乱序的,
需要保证 response 按照 request 的时序排序, 永远取最新值 render.

```
request 顺序: A -> B -> C -> D
但 response 的顺序可能是: A -> C -> D -> B
```

我们先行定义一些基础代码如下:

```js
// 假设我们的查询条件定义如下
let opts = { /* ... */ }

// 当用户变更查询条件时, 视图层做相应变更
opts = Object.assign({}, opts, { /* ... */ })

// 假设 http request 函数如下
async function request(query) { /* ... */ }
```

上述的需求再细化, 有如下几点:

1. 请求行为是随着用户操作不断进行的, 也就是 `无限`
2. 不能将请求同步化, 上文提到, 我们的请求比较耗时
3. 结果必须是最后一次请求的结果, 否则, 查询结果与筛选条件不一致
4. 当后一次请求结束时 (拿到结果), 在这之前发出的所有请求其实都无意义了 (至少对前端是如此 >_<)

不知道读者朋友有没有能用很少代码便实现上述需求的,
至少我个人琢磨了下, 实现上述需求还是需要一定代码量的.

如果使用 `rxjs`, 这种需求是很好解决的

```js
Observable.interval(500)
  .map(() => opts)
  .distinctUntilChanged()
  .switchMap(opts => request(opts))
  .subscribe(data => {
    /* render */
  })
```

在 `rxjs` 加持下, 基本 `5行` 代码便满足了我们的需求

